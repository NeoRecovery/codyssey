# 1. Run Without Debugging vs Start Debugging

## Run Without Debugging
코드가 디버거 연결 없이 실행 - 브레이크포인트, 변수 워치, 콜 스택 탐색 불가
실행 속도가 약간 더 빠르고, 디버깅 오버헤드가 없습니다.
오류 발생 시 터미널에 스택 트레이스만 출력

## Start Debugging
코드가 디버거 모드 실행 - 브레이크포인트, 스텝 실행, 변수 값 조회/수정, 콜 스택 탐색 등 풍부한 디버깅 기능 사용 가능
디버거가 백그라운드에서 프로세스를 제어 약간의 성능 저하 발생
예기치 않은 예외 발생 시 중단점에서 멈추고 상태를 바로 확인


# 2. Flask의 역할 요약
경량(마이크로) 웹 프레임워크
최소한의 핵심만 제공 → 필요에 따라 확장 가능
WSGI 애플리케이션 구조
HTTP 요청을 받아 라우팅·뷰 함수로 연결
라우팅 및 뷰 함수 관리
@app.route() 데코레이터로 URL 매핑
템플릿 렌더링
Jinja2 기반 → HTML/CSS 파일에 동적 데이터 삽입
확장성
SQLAlchemy, Flask-Login, Flask-Migrate 등 다양한 확장 패키지와 연동

# 3. 호스트를 0.0.0.0으로 설정할 때
“모든 네트워크 인터페이스”에서 오는 요청을 수신
외부에서도 접근 가능

## 장점

여러 외부 접근에 대한 테스트 가능 - 내부 서비스가 외부 요청 수신

## 단점
보안 위험: 방화벽 또는 인증 설정 없으면 외부에서 무차별 접근 가능
실제 운영 환경에서는 HTTPS, 방화벽 등에 두게 됨.

# 4. 127.0.0.1 접속 vs 내부 IP 접속
호스트 컴퓨터 내부만 vs 같은 로컬 네트워크 내의 다른 기기들도 접근 가능
외부 차단 → 비교적 안전 vs 네트워크 구성에 따라 외부 침입 위험 존재
개발·테스트용 로컬 서비스 vs LAN 환경에서 여러 디바이스 간 협업·테스트 용도

# 5. 포트 번호의 의미와 충돌 해결 방안
## 포트 번호란?
하나의 IP 주소에서 서비스 구분을 위한 식별자
## 충돌 발생 원인
다른 서비스가 동일 포트 점유
## 해결 방안
기존 서비스 사용해야하고 새로운 서비스라면 app.run(port=8888) 등으로 포트 변경
기존 서비스를 사용하지 않겠다면 기존 프로세스 종료 후 새로운 서비스 실행